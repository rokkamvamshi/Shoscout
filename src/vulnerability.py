# vulnerability.py - Check for common vulnerabilities

import requests
import urllib3
import concurrent.futures
import socket
import ssl
from bs4 import BeautifulSoup
import json
import re

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class VulnerabilityChecker:
    def __init__(self, shodan_client=None):
        self.shodan_client = shodan_client
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        }
        
        # Common vulnerability checks keyed by service
        self.checks = {
            'web': [
                self._check_xss,
                self._check_open_redirect,
                self._check_sqli,
                self._check_ssrf,
                self._check_cors_misconfig,
                self._check_exposed_git
            ],
            'ssl': [
                self._check_heartbleed,
                self._check_ssl_vulnerabilities
            ]
        }
        
        # Load vulnerability signatures
        self.vuln_signatures = self._load_signatures()
    
    def _load_signatures(self):
        """Load vulnerability signatures from file or default to basic ones"""
        try:
            with open('config/vuln_signatures.json', 'r') as f:
                return json.load(f)
        except:
            # Return default signatures
            return {
                'web': {
                    'exposed_git': ['.git/HEAD', '.git/config'],
                    'exposed_env': ['.env', '.env.local', '.env.backup'],
                    'debug_pages': ['phpinfo.php', 'debug.php', 'test.php'],
                    'default_pages': ['setup.php', 'install.php', 'admin/install.php'],
                    'xss_params': ['q', 'search', 'id', 'lang', 'keyword', 'query'],
                    'sqli_params': ['id', 'page_id', 'user_id', 'item', 'cat', 'product'],
                    'lfi_params': ['page', 'file', 'view', 'template', 'path', 'include'],
                    'open_redirect_params': ['url', 'redirect', 'next', 'goto', 'target', 'destination', 'redir', 'return_url']
                },
                'ssl': {
                    'weak_ciphers': ['TLS_RSA_WITH_RC4', 'TLS_RSA_WITH_DES', 'SSL_RSA_WITH_DES', 'TLS_RSA_EXPORT']
                }
            }
    
    def check_vulnerabilities(self, ip_mapping, port_results):
        """Check for vulnerabilities in detected services"""
        print(f"[+] Checking for vulnerabilities on {len(port_results)} hosts")
        vulnerabilities = {}
        
        # Process each host
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            future_to_host = {}
            
            for hostname, port_data in port_results.items():
                # Skip if no ports found
                if not port_data:
                    continue
                
                # Get IP for Shodan lookup
                ip = ip_mapping.get(hostname)
                
                # Check vulnerabilities using Shodan data if available
                if self.shodan_client and ip:
                    future = executor.submit(self._check_shodan_vulns, ip)
                    future_to_host[(hostname, 'shodan')] = future
                
                # Check web vulnerabilities
                web_ports = self._get_web_ports(port_data)
                for port in web_ports:
                    # Determine protocol
                    protocol = 'https' if port in [443, 8443] else 'http'
                    url = f"{protocol}://{hostname}:{port}"
                    
                    future = executor.submit(self._check_web_vulnerabilities, url)
                    future_to_host[(hostname, f'web-{port}')] = future
                
                # Check SSL vulnerabilities
                ssl_ports = self._get_ssl_ports(port_data)
                for port in ssl_ports:
                    future = executor.submit(self._check_ssl_vulnerabilities, hostname, port)
                    future_to_host[(hostname, f'ssl-{port}')] = future
            
            # Process results
            for (hostname, check_type), future in future_to_host.items():
                try:
                    result = future.result()
                    if result:
                        if hostname not in vulnerabilities:
                            vulnerabilities[hostname] = {}
                        
                        if check_type.startswith('web-'):
                            port = check_type.split('-')[1]
                            if 'web' not in vulnerabilities[hostname]:
                                vulnerabilities[hostname]['web'] = {}
                            vulnerabilities[hostname]['web'][port] = result
                        elif check_type.startswith('ssl-'):
                            port = check_type.split('-')[1]
                            if 'ssl' not in vulnerabilities[hostname]:
                                vulnerabilities[hostname]['ssl'] = {}
                            vulnerabilities[hostname]['ssl'][port] = result
                        elif check_type == 'shodan':
                            vulnerabilities[hostname]['shodan'] = result
                except Exception as e:
                    print(f"[-] Error checking vulnerabilities for {hostname} ({check_type}): {e}")
        
        return vulnerabilities
    
    def _get_web_ports(self, port_data):
        """Extract web service ports from port data"""
        web_ports = []
        
        for proto in port_data:
            if proto != 'tcp':
                continue
                
            for port, service in port_data[proto].items():
                port = int(port)
                service_name = service.get('name', '').lower()
                
                # Common web service names
                if service_name in ['http', 'https', 'http-proxy', 'http-alt']:
                    web_ports.append(port)
                # Common web ports
                elif port in [80, 443, 8080, 8443, 8000, 8888, 3000]:
                    web_ports.append(port)
        
        return web_ports
    
    def _get_ssl_ports(self, port_data):
        """Extract SSL/TLS service ports from port data"""
        ssl_ports = []
        
        for proto in port_data:
            if proto != 'tcp':
                continue
                
            for port, service in port_data[proto].items():
                port = int(port)
                service_name = service.get('name', '').lower()
                
                # Common SSL service names
                if 'ssl' in service_name or 'tls' in service_name or service_name == 'https':
                    ssl_ports.append(port)
                # Common SSL ports
                elif port in [443, 8443, 465, 993, 995]:
                    ssl_ports.append(port)
        
        return ssl_ports
    
    def _check_shodan_vulns(self, ip):
        """Check for vulnerabilities using Shodan data"""
        if not self.shodan_client:
            return None
        
        vulnerabilities = {}
        
        try:
            # Get host information from Shodan
            host_info = self.shodan_client.host_lookup(ip)
            
            if not host_info:
                return None
            
            # Check for CVEs
            if 'vulns' in host_info:
                vulnerabilities['cves'] = list(host_info['vulns'])
            
            # Extract other useful information
            if 'tags' in host_info:
                vulnerabilities['tags'] = host_info['tags']
            
            # Check for exploits
            if 'exploits' in host_info:
                vulnerabilities['exploits'] = host_info['exploits']
            
            return vulnerabilities if vulnerabilities else None
            
        except Exception as e:
            print(f"[-] Error checking Shodan vulnerabilities for {ip}: {e}")
            return None
    
    def _check_web_vulnerabilities(self, base_url):
        """Check for common web vulnerabilities"""
        results = {}
        
        # Basic connection check
        try:
            response = requests.get(base_url, 
                                   timeout=10, 
                                   verify=False, 
                                   headers=self.headers)
        except:
            # Can't connect, skip checks
            return None
        
        # Run the vulnerability checks
        for check_function in self.checks['web']:
            try:
                check_name = check_function.__name__.replace('_check_', '')
                result = check_function(base_url)
                if result:
                    results[check_name] = result
            except Exception as e:
                print(f"[-] Error in {check_function.__name__} for {base_url}: {e}")
        
        return results if results else None
    
    def _check_ssl_vulnerabilities(self, hostname, port):
        """Check for SSL/TLS vulnerabilities"""
        results = {}
        
        # Basic SSL check
        try:
            # Create socket
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssl_sock:
                    # Get SSL version and cipher
                    ssl_version = ssl_sock.version()
                    cipher = ssl_sock.cipher()
                    
                    # Check for weak SSL/TLS versions
                    if 'SSLv2' in ssl_version or 'SSLv3' in ssl_version:
                        results['weak_protocol'] = ssl_version
                    
                    # Check for weak ciphers
                    cipher_name = cipher[0]
                    for weak_cipher in self.vuln_signatures['ssl']['weak_ciphers']:
                        if weak_cipher in cipher_name:
                            if 'weak_ciphers' not in results:
                                results['weak_ciphers'] = []
                            results['weak_ciphers'].append(cipher_name)
                    
                    # Get certificate expiration
                    cert = ssl_sock.getpeercert()
                    if cert and 'notAfter' in cert:
                        # TODO: Check for expiration
                        pass
        except:
            # Can't connect with SSL, skip checks
            pass
        
        # Check for Heartbleed
        heartbleed_result = self._check_heartbleed(hostname, port)
        if heartbleed_result:
            results['heartbleed'] = heartbleed_result
        
        return results if results else None
    
    def _check_xss(self, base_url):
        """Check for potential XSS vulnerabilities"""
        results = []
        
        # Test XSS through common parameters
        for param in self.vuln_signatures['web']['xss_params']:
            test_payload = f"<script>alert(1)</script>"
            test_url = f"{base_url}/?{param}={test_payload}"
            
            try:
                response = requests.get(test_url, 
                                      timeout=5, 
                                      verify=False, 
                                      headers=self.headers)
                
                # Check if payload is reflected
                if test_payload in response.text:
                    results.append({
                        'param': param,
                        'url': test_url,
                        'reflected': True
                    })
            except:
                continue
        
        return results if results else None
    
    def _check_open_redirect(self, base_url):
        """Check for open redirect vulnerabilities"""
        results = []
        
        test_destination = "https://example.com"
        
        for param in self.vuln_signatures['web']['open_redirect_params']:
            test_url = f"{base_url}/?{param}={test_destination}"
            
            try:
                response = requests.get(test_url, 
                                      timeout=5, 
                                      verify=False, 
                                      headers=self.headers,
                                      allow_redirects=False)
                
                # Check for redirect
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    if test_destination in location:
                        results.append({
                            'param': param,
                            'url': test_url,
                            'location': location
                        })
            except:
                continue
        
        return results if results else None
    
    def _check_sqli(self, base_url):
        """Check for potential SQL injection vulnerabilities"""
        results = []
        
        # Test SQLi through common parameters
        for param in self.vuln_signatures['web']['sqli_params']:
            # Test basic SQL error patterns
            test_payloads = [
                "1'", 
                "1\"", 
                "1 OR 1=1", 
                "1' OR '1'='1", 
                "1\" OR \"1\"=\"1"
            ]
            
            for payload in test_payloads:
                test_url = f"{base_url}/?{param}={payload}"
                
                try:
                    response = requests.get(test_url, 
                                          timeout=5, 
                                          verify=False, 
                                          headers=self.headers)
                    
                    # Check for SQL error messages
                    sql_errors = [
                        "SQL syntax",
                        "syntax error",
                        "mysql_fetch_array",
                        "mysql_result",
                        "pg_query",
                        "ORA-",
                        "unclosed quotation mark"
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in response.text.lower():
                            results.append({
                                'param': param,
                                'payload': payload,
                                'url': test_url,
                                'error': error
                            })
                            break
                except:
                    continue
        
        return results if results else None
    
    def _check_ssrf(self, base_url):
        """Check for Server-Side Request Forgery vulnerabilities"""
        # This is a simplified check for demonstration
        # Real SSRF checks might use callback servers
        return None
    
    def _check_cors_misconfig(self, base_url):
        """Check for CORS misconfigurations"""
        test_origin = "https://malicious-site.com"
        
        try:
            headers = self.headers.copy()
            headers['Origin'] = test_origin
            
            response = requests.get(base_url, 
                                   timeout=5, 
                                   verify=False, 
                                   headers=headers)
            
            acao_header = response.headers.get('Access-Control-Allow-Origin')
            
            if acao_header:
                if acao_header == '*' or acao_header == test_origin:
                    acac_header = response.headers.get('Access-Control-Allow-Credentials')
                    
                    if acac_header and acac_header.lower() == 'true':
                        return {
                            'allow_origin': acao_header,
                            'allow_credentials': acac_header,
                            'vulnerable': True
                        }
        except:
            pass
        
        return None
    
    def _check_exposed_git(self, base_url):
        """Check for exposed .git directory"""
        try:
            git_url = f"{base_url}/.git/HEAD"
            response = requests.get(git_url, 
                                   timeout=5, 
                                   verify=False, 
                                   headers=self.headers)
            
            if response.status_code == 200 and 'ref:' in response.text:
                return {
                    'url': git_url,
                    'exposed': True
                }
        except:
            pass
        
        return None
    
    def _check_heartbleed(self, hostname, port):
        """Check for Heartbleed vulnerability (CVE-2014-0160)"""
        # This is a placeholder - actual Heartbleed check would require custom TLS handling
        # In a real tool, you might use specialized libraries or tools
        return None